const { CalendarEventInput } = require("./calendarEventService");

const WORK_START_HOUR = 8;
const WORK_END_HOUR = 20;
const SLOT_INCREMENT_MINUTES = 30;

function toDate(value) {
	if (!value) return null;
	if (value instanceof Date) return new Date(value.getTime());
	const date = new Date(value);
	return Number.isNaN(date.getTime()) ? null : date;
}

function eventToInterval(event) {
	if (!event) return null;
	const startValue = event.start?.dateTime || event.start?.date;
	if (!startValue) return null;
	const start = toDate(startValue?.dateTime ? startValue.dateTime : startValue);
	let endValue = event.end?.dateTime || event.end?.date;
	let end = endValue ? toDate(endValue) : null;
	if (!end || !(end > start)) {
		end = new Date(start.getTime() + 60 * 60 * 1000);
	}
	return { start, end, source: event.summary || "" };
}

function taskToInterval(task) {
	const start = toDate(task.start);
	const end = toDate(task.end);
	if (!start || !end || !(end > start)) return null;
	return { start, end, source: task.title || "task" };
}

function clipInterval(interval, windowStart, windowEnd) {
	if (!interval) return null;
	const start =
		interval.start < windowStart ? new Date(windowStart) : interval.start;
	const end = interval.end > windowEnd ? new Date(windowEnd) : interval.end;
	if (!(end > start)) return null;
	return { start, end, source: interval.source };
}

function mergeIntervals(intervals = []) {
	if (!intervals.length) return [];
	const sorted = intervals
		.filter(
			(entry) => entry && entry.start && entry.end && entry.end > entry.start
		)
		.sort((a, b) => a.start.getTime() - b.start.getTime());
	const merged = [sorted[0]];
	for (let i = 1; i < sorted.length; i += 1) {
		const current = sorted[i];
		const last = merged[merged.length - 1];
		if (current.start <= last.end) {
			if (current.end > last.end) last.end = current.end;
		} else {
			merged.push({ ...current });
		}
	}
	return merged;
}

function roundUpToIncrement(date, minutes) {
	const ms = minutes * 60 * 1000;
	const rounded = new Date(Math.ceil(date.getTime() / ms) * ms);
	return rounded;
}

function setTime(date, hour, minute = 0) {
	const next = new Date(date);
	next.setHours(hour, minute, 0, 0);
	return next;
}

function addMinutes(date, minutes) {
	return new Date(date.getTime() + minutes * 60 * 1000);
}

function moveToNextWorkdayStart(date) {
	const nextDay = new Date(date);
	nextDay.setDate(nextDay.getDate() + 1);
	return setTime(nextDay, WORK_START_HOUR, 0);
}

function findAvailableSlots({
	windowStart,
	windowEnd,
	durationMinutes,
	sessionCount,
	busyIntervals,
}) {
	const slots = [];
	let pointer = roundUpToIncrement(windowStart, SLOT_INCREMENT_MINUTES);
	let safeBusy = mergeIntervals(busyIntervals);

	while (pointer < windowEnd && slots.length < sessionCount) {
		const dayStart = setTime(pointer, WORK_START_HOUR);
		const dayEnd = setTime(pointer, WORK_END_HOUR);
		if (pointer < dayStart) {
			pointer = dayStart;
		}
		if (pointer >= dayEnd) {
			pointer = moveToNextWorkdayStart(pointer);
			continue;
		}

		const slotEnd = addMinutes(pointer, durationMinutes);
		if (slotEnd > windowEnd) break;
		if (slotEnd > dayEnd) {
			pointer = moveToNextWorkdayStart(pointer);
			continue;
		}

		const conflict = safeBusy.find(
			(interval) => pointer < interval.end && slotEnd > interval.start
		);
		if (conflict) {
			pointer = roundUpToIncrement(conflict.end, SLOT_INCREMENT_MINUTES);
			continue;
		}

		slots.push({ start: new Date(pointer), end: slotEnd });
		safeBusy = mergeIntervals(
			safeBusy.concat([{ start: new Date(pointer), end: slotEnd }])
		);
		pointer = roundUpToIncrement(
			addMinutes(slotEnd, SLOT_INCREMENT_MINUTES),
			SLOT_INCREMENT_MINUTES
		);
	}

	return slots;
}

function sanitizeEvents(events = []) {
	return events.map((evt, index) => {
		try {
			const parsed = CalendarEventInput.parse(evt);
			return parsed;
		} catch (err) {
			throw new Error(
				`Invalid event payload at index ${index}: ${err.message}`
			);
		}
	});
}

function buildStudyEvents({ syllabusTitle, slots, sessionCount }) {
	return slots.map((slot, index) => ({
		summary: `Study: ${syllabusTitle || "Course"} (Session ${
			index + 1
		} of ${sessionCount})`,
		description: `Suggested focus time for ${
			syllabusTitle || "your class"
		}. Generated by Sylly planner.`,
		start: { dateTime: slot.start.toISOString() },
		end: { dateTime: slot.end.toISOString() },
	}));
}

function assembleBusyIntervals({
	windowStart,
	windowEnd,
	syllabusEvents = [],
	googleEvents = [],
	tasks = [],
}) {
	const intervals = [];
	const clip = (interval) => clipInterval(interval, windowStart, windowEnd);

	syllabusEvents
		.map(eventToInterval)
		.map(clip)
		.forEach((interval) => interval && intervals.push(interval));

	googleEvents
		.map(eventToInterval)
		.map(clip)
		.forEach((interval) => interval && intervals.push(interval));

	tasks
		.map(taskToInterval)
		.map(clip)
		.forEach((interval) => interval && intervals.push(interval));

	return mergeIntervals(intervals);
}

function generateStudyPlan({
	syllabusTitle,
	windowStart,
	windowEnd,
	durationMinutes,
	sessionCount,
	syllabusEvents,
	googleEvents,
	tasks,
}) {
	if (!(windowEnd > windowStart)) {
		throw new Error("Invalid planning window");
	}
	const busyIntervals = assembleBusyIntervals({
		windowStart,
		windowEnd,
		syllabusEvents,
		googleEvents,
		tasks,
	});
	const slots = findAvailableSlots({
		windowStart,
		windowEnd,
		durationMinutes,
		sessionCount,
		busyIntervals,
	});
	const events = buildStudyEvents({ syllabusTitle, slots, sessionCount });
	return {
		slots,
		events,
		busyCount: busyIntervals.length,
	};
}

module.exports = {
	generateStudyPlan,
	sanitizeEvents,
	assembleBusyIntervals,
	eventToInterval,
	taskToInterval,
};
